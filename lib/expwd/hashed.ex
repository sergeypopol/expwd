defmodule Expwd.Hashed do

  @type t :: %__MODULE__{
    alg: atom(),
    hash: binary()
  }

  @enforce_keys [:alg, :hash]
  defstruct [:alg, :hash]

  @doc """
  Securely and randomly generates a new application password

  Returns a 2-element tuple containing:
  - the plaintext password
  - the hashed password encapsulated in the `%Expwd.Hashed{}` structure

  ## Example
  ```elixir
  iex> {plaintext, hashedpwd} = Expwd.Hashed.gen()
  {"3vDkDVeQFzH5HhE3s0yAO96CjwgzXOS2TJOOlenoERg",
   %Expwd.Hashed{
     alg: :sha256,
     hash: <<125, 4, 175, 176, 235, 73, 77, 50, 180, 102, 178, 13, 255, 140, 175,
       223, 181, 53, 249, 77, 121, 81, 78, 77, 194, 111, 26, 216, 46, 80, 94,
       175>>
   }}
  ```
  """

  @spec gen() :: {String.t, t}
  def gen() do
    pwd = Base.encode64(:crypto.strong_rand_bytes(32), padding: false)

    {
      pwd,
      new(pwd)
    }
  end

  @doc """
  Returns a `%Expwd.Hashed{}` structure from a cleartext password. The cleartext password is hashed

  ## Example
  ```elixir
  iex(2)> Expwd.Hashed.new("VDr7o6JbU24u4hFxqCcWun7u1R1fsD8IAWdtC0YtRRc")
  %Expwd.Hashed{
    alg: :sha256,
    hash: <<124, 206, 231, 219, 155, 9, 125, 107, 29, 98, 59, 95, 162, 249, 196,
      69, 195, 215, 178, 123, 204, 111, 18, 236, 13, 136, 117, 95, 252, 79, 180,
      27>>
  }
  ```
  """

  @spec new(binary, Expwd.supported_algs) :: t
  def new(password, alg \\ :sha256)
  def new(password, alg) do
    if alg not in Expwd.supported_hash_algorithms()
    do
      raise Expwd.UnsupportedHashAlgorithm, message: "Unsupported hash algorithm #{alg}"
    end

    %__MODULE__{
      alg: alg,
      hash: :crypto.hash(alg, password)
    }
  end

  @doc """
  Returns an Expwd library specific string representation of a `%Expwd.Hashed{}`

  The string representation does not contains the cleartext password and can therefore safely be stored (in databases, plain files, configuration files...)

  ## Example
  ```elixir
  iex> Expwd.Hashed.to_string(%Expwd.Hashed{
  ...>    alg: :sha256,
  ...>    hash: <<187, 113, 125, 3, 107, 9, 176, 47, 52, 211, 5, 221, 172, 252, 132,
  ...>      77, 62, 226, 67, 123, 247, 152, 216, 95, 196, 125, 54, 124, 109, 200, 92,
  ...>      223>>
  ...>  })
  "expwd:sha256:u3F9A2sJsC800wXdrPyETT7iQ3v3mNhfxH02fG3IXN8"
  ```
  """

  @spec to_string(t) :: String.t
  def to_string(%Expwd.Hashed{alg: alg, hash: hash}) do
    "expwd:#{alg}:#{Base.encode64(hash, padding: false)}"
  end

  @doc """
  Returns a `%Expwd.Hashed{}` from a `Expwd.Hashed` string representation generated by the `to_string` function

  ## Example
  ```elixir
  iex> Expwd.Hashed.from_string("expwd:sha256:C1brx7Gzuk62lqtZX2gLLtghP0NeybNOrO531SHQOn0")
  %Expwd.Hashed{
    alg: :sha256,
    hash: <<11, 86, 235, 199, 177, 179, 186, 78, 182, 150, 171, 89, 95, 104, 11,
      46, 216, 33, 63, 67, 94, 201, 179, 78, 172, 238, 119, 213, 33, 208, 58,
      125>>
  }
  ```
  """

  @spec from_string(String.t) :: t
  def from_string(str_expwd) do
    ["expwd", alg, b64_binary] = String.split(str_expwd, ":")

    supported_hash_algorithms_str =
      Enum.map(Expwd.supported_hash_algorithms(),
               fn val -> Atom.to_string(val) end)

    if alg not in supported_hash_algorithms_str do
      raise Expwd.UnsupportedHashAlgorithm, message: "Unsupported hash algorithm " <> alg
    end

    %__MODULE__{
      alg: String.to_atom(alg),
      hash: Base.decode64!(b64_binary, padding: false)
    }
  end
end
