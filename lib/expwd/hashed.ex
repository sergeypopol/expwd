defmodule Expwd.Hashed do

  @type t :: %__MODULE__{
    alg: atom(),
    hash: binary()
  }

  @enforce_keys [:alg, :hash]
  defstruct [:alg, :hash]

  @doc """
  Securely and randomly generates a new application password

  Returns a 2-element tuple containing:
  - the plaintext password
  - the hashed password encapsulated in the `%Expwd.Hashed{}` structure

  ## Example
  ```elixir
  iex> {plaintext, hashedpwd} = Expwd.Hashed.gen()
  {"3vDkDVeQFzH5HhE3s0yAO96CjwgzXOS2TJOOlenoERg",
   %Expwd.Hashed{
     alg: :sha256,
     hash: <<125, 4, 175, 176, 235, 73, 77, 50, 180, 102, 178, 13, 255, 140, 175,
       223, 181, 53, 249, 77, 121, 81, 78, 77, 194, 111, 26, 216, 46, 80, 94,
       175>>
   }}
  ```
  """

  @spec gen() :: {String.t, t}
  def gen() do
    pwd = Base.encode64(:crypto.strong_rand_bytes(32), padding: false)

    {
      pwd,
      new(pwd)
    }
  end

  @doc """
  Returns a `%Expwd.Hashed{}` structure from a cleartext password. The cleartext password is hashed

  ## Example
  ```elixir
  iex(2)> Expwd.Hashed.new("VDr7o6JbU24u4hFxqCcWun7u1R1fsD8IAWdtC0YtRRc")
  %Expwd.Hashed{
    alg: :sha256,
    hash: <<124, 206, 231, 219, 155, 9, 125, 107, 29, 98, 59, 95, 162, 249, 196,
      69, 195, 215, 178, 123, 204, 111, 18, 236, 13, 136, 117, 95, 252, 79, 180,
      27>>
  }
  ```
  """

  @spec new(binary, Expwd.supported_algs) :: t
  def new(password, alg \\ :sha256)
  def new(password, alg) do
    if alg not in Expwd.supported_hash_algorithms()
    do
      raise Expwd.UnsupportedHashAlgorithm, message: "Unsupported hash algorithm #{alg}"
    end

    %__MODULE__{
      alg: alg,
      hash: :crypto.hash(alg, password)
    }
  end

  defmodule Portable do
    @type t :: {:expwd, Expwd.supported_algs, String.t}

    @doc """
    Returns a portable representation of an `%Expwd.Hashed{}`

    The portable representation does not contains the cleartext password and can therefore safely be stored (in databases, plain files, configuration files...)

    ## Example
    ```elixir
    iex> Expwd.Hashed.Portable.to_portable( %Expwd.Hashed{
    ...>    alg: :sha256,
    ...>    hash: <<225, 202, 137, 75, 79, 76, 179, 173, 210, 149, 122, 70, 140, 15, 138,
    ...>      224, 117, 154, 139, 9, 7, 155, 139, 244, 105, 140, 27, 177, 249, 144, 105,
    ...>      164>>
    ...>  })
    {:expwd, :sha256, "4cqJS09Ms63SlXpGjA+K4HWaiwkHm4v0aYwbsfmQaaQ"}

    ```
    """

    @spec to_portable(Expw.Hashe.t) :: t
    def to_portable(%Expwd.Hashed{alg: alg, hash: hash}) do
      {:expwd, alg, Base.encode64(hash, padding: false)}
    end

    @doc """
    Returns a `%Expwd.Hashed{}` from a portable representation generated by the `to_portable` function

    ## Example
    ```elixir
    iex> Expwd.Hashed.Portable.from_portable({:expwd, :sha256, "4cqJS09Ms63SlXpGjA+K4HWaiwkHm4v0aYwbsfmQaaQ"})
    %Expwd.Hashed{
      alg: :sha256,
      hash: <<225, 202, 137, 75, 79, 76, 179, 173, 210, 149, 122, 70, 140, 15, 138,
        224, 117, 154, 139, 9, 7, 155, 139, 244, 105, 140, 27, 177, 249, 144, 105,
        164>>
    }
    ```
    """

    @spec from_portable(t) :: Expwd.Hashed.t
    def from_portable({:expwd, alg, b64_hash}) do

      if alg not in Expwd.supported_hash_algorithms() do
        raise Expwd.UnsupportedHashAlgorithm, message: "Unsupported hash algorithm " <> alg
      end

      %Expwd.Hashed{
        alg: alg,
        hash: Base.decode64!(b64_hash, padding: false)
      }
    end
  end
end
