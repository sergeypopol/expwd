defmodule Expwd.Hashed do

  @type t :: %__MODULE__{
    alg: atom(),
    hash: binary()
  }

  @enforce_keys [:alg, :hash]
  defstruct [:alg, :hash]

  @doc """
  Securely and randomly generates a new application password

  Returns a 2-element tuple containing:
  - the plaintext password
  - the hashed password encapsulated in the `%Expwd.Hashed{}` structure

  ## Example
  ```elixir
  iex> {plaintext, hashedpwd} = Expwd.Hashed.gen()
  {"3vDkDVeQFzH5HhE3s0yAO96CjwgzXOS2TJOOlenoERg",
   %Expwd.Hashed{
     alg: :sha256,
     hash: <<125, 4, 175, 176, 235, 73, 77, 50, 180, 102, 178, 13, 255, 140, 175,
       223, 181, 53, 249, 77, 121, 81, 78, 77, 194, 111, 26, 216, 46, 80, 94,
       175>>
   }}
  ```
  """

  @spec gen() :: {String.t, t}
  def gen() do
    pwd = Base.encode64(:crypto.strong_rand_bytes(32), padding: false)

    {
      pwd,
      new(pwd)
    }
  end

  @doc """
  Returns a `%Expwd.Hashed{}` structure from a cleartext password. The cleartext password is hashed

  ## Example
  ```elixir
  iex(2)> Expwd.Hashed.new("VDr7o6JbU24u4hFxqCcWun7u1R1fsD8IAWdtC0YtRRc")
  %Expwd.Hashed{
    alg: :sha256,
    hash: <<124, 206, 231, 219, 155, 9, 125, 107, 29, 98, 59, 95, 162, 249, 196,
      69, 195, 215, 178, 123, 204, 111, 18, 236, 13, 136, 117, 95, 252, 79, 180,
      27>>
  }
  ```
  """

  @spec new(binary, Expwd.supported_algs) :: t
  def new(password, alg \\ :sha256)
  def new(password, alg) do
    if alg not in Expwd.supported_hash_algorithms()
    do
      raise Expwd.UnsupportedHashAlgorithm, message: "Unsupported hash algorithm #{alg}"
    end

    %__MODULE__{
      alg: alg,
      hash: :crypto.hash(alg, password)
    }
  end

  defmodule Portable do
    @type t :: String.t()

    @doc """
    Returns a string representation of an `%Expwd.Hashed{}`

    The portable string format can contains all characters of the base64 URL encoding and ":". It
    starts with the string `"expwd:"`.

    The portable representation does not contains the cleartext password and can therefore
    safely be stored (in databases, plain files, configuration files...).

    ## Example
    ```elixir
    iex> {pwd, hashed} = Expwd.Hashed.gen()
    {"mkEMrKBnw/qKP9KOx66EEvPtb06vzvJdFzz7m0m2P8c",
     %Expwd.Hashed{
       alg: :sha256,
       hash: <<43, 13, 74, 254, 1, 242, 163, 122, 21, 174, 244, 13, 155, 124, 183,
         88, 139, 42, 121, 153, 0, 95, 172, 100, 34, 230, 255, 182, 250, 50, 239,
         146>>
     }}
    iex> Expwd.Hashed.Portable.to_portable(hashed)
    "expwd:sha256:Kw1K/gHyo3oVrvQNm3y3WIsqeZkAX6xkIub/tvoy75I"
    ```
    """

    @spec to_portable(Expwd.Hashed.t) :: t
    def to_portable(%Expwd.Hashed{alg: alg, hash: hash}) do
      "expwd:" <> to_string(alg) <> ":" <> Base.encode64(hash, padding: false)
    end

    @doc """
    Returns a `%Expwd.Hashed{}` from a portable representation generated by the `to_portable/1`
    function

    ## Example
    ```elixir
    iex> Expwd.Hashed.Portable.from_portable("expwd:sha256:Kw1K/gHyo3oVrvQNm3y3WIsqeZkAX6xkIub/tvoy75I")
    %Expwd.Hashed{
      alg: :sha256,
      hash: <<43, 13, 74, 254, 1, 242, 163, 122, 21, 174, 244, 13, 155, 124, 183,
        88, 139, 42, 121, 153, 0, 95, 172, 100, 34, 230, 255, 182, 250, 50, 239,
        146>>
    }
    ```
    """

    @spec from_portable(t) :: Expwd.Hashed.t

    def from_portable("expwd:" <> alg_and_digest) do
      [alg_str, digest_b64] = String.split(alg_and_digest, ":")

      alg = String.to_existing_atom(alg_str)

      if alg not in Expwd.supported_hash_algorithms() do
        raise Expwd.UnsupportedHashAlgorithm, message: "Unsupported hash algorithm " <> to_string(alg)
      end

      %Expwd.Hashed{
        alg: alg,
        hash: Base.decode64!(digest_b64, padding: false)
      }
    end
  end
end
